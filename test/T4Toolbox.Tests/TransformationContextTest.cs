// <copyright file="TransformationContextTest.cs" company="Oleg Sych">
//  Copyright © Oleg Sych. All Rights Reserved.
// </copyright>

namespace T4Toolbox.Tests
{
    using System;
    using System.CodeDom.Compiler;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Runtime.Remoting.Messaging;
    using System.Text;
    using Microsoft.VisualStudio.TextTemplating;

    /// <summary>
    /// This is a test class for <see cref="TransformationContext"/> and is intended
    /// to contain all of its unit tests.
    /// </summary>
    public class TransformationContextTest
    {
        private const string TestText = "Test Text";

        private const string TestFile = "Test.txt";

        #region Cleanup

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "value", Justification = "C# can't invoke property getter without a variable.")]
        [Fact]
        public void CleanupRemovesCurrent()
        {
            using (var transformation = new FakeTransformation())
            {
                TransformationContext.Initialize(transformation, transformation.GenerationEnvironment);
                TransformationContext.Cleanup();
                Assert.Throws<TransformationException>(() => _ = TransformationContext.Current);
            }
        }

        [Fact]
        public void CleanupDisposesCurrent()
        {
            using (var transformation = new FakeTransformation())
            {
                bool disposed = false;
                TransformationContext.Initialize(transformation, transformation.GenerationEnvironment);
                try
                {
                    TransformationContext.Current.Disposed += delegate { disposed = true; };
                }
                finally
                {
                    TransformationContext.Cleanup();
                }

                Assert.True(disposed);
            }
        }

        [Fact]
        public void CleanupDoesNotThrowExceptionsWhenContextIsNullBecauseTheyWouldObscureInitializationExceptions()
        {
            TransformationContext.Cleanup();
        }

        #endregion

        #region Constructor

        /// <summary>
        /// Mimics code generated by T4 based on &lt;#@ parameter type="System.String" name="StringParameter" #&gt; directive.
        /// </summary>
        private class FakeTransformationWithStringParameter : FakeTransformation
        {
            private readonly string stringParameter = string.Empty;

            private string StringParameter
            {
                get { return this.stringParameter; }
            }
        }

        [Fact]
        public void ConstructorAddsMetadataValuesForMatchingParametersToTransformationSession()
        {
            using (var transformation = new FakeTransformationWithStringParameter())
            {
                const string ExpectedValue = "TestValue";
                const string ParameterName = "StringParameter";
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) => metadataName == ParameterName ? ExpectedValue : null;
                using (new TransformationContext(transformation, transformation.GenerationEnvironment))
                {
                    Assert.Equal(ExpectedValue, transformation.Session[ParameterName]);
                }
            }
        }

        [Fact]
        public void ConstructorDoesNotOverrideParameterValuesSuppliedViaTransformationSession()
        {
            using (var transformation = new FakeTransformationWithStringParameter())
            {
                const string ExpectedValue = "SessionValue";
                const string ParameterName = "StringParameter";
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) => metadataName == ParameterName ? "MetadataValue" : null;
                transformation.Session[ParameterName] = ExpectedValue;
                using (new TransformationContext(transformation, transformation.GenerationEnvironment))
                {
                    Assert.Equal(ExpectedValue, transformation.Session[ParameterName]);
                }
            }
        }

        [Fact]
        public void ConstructorDoesNotOverrideParameterValuesSuppliedViaCallContext()
        {
            using (var transformation = new FakeTransformationWithStringParameter())
            {
                const string ParameterName = "StringParameter";
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) => metadataName == ParameterName ? "MetadataValue" : null;
                CallContext.LogicalSetData(ParameterName, "CallContextValue");
                try
                {
                    using (new TransformationContext(transformation, transformation.GenerationEnvironment))
                    {
                        Assert.False(transformation.Session.ContainsKey(ParameterName));
                    }
                }
                finally
                {
                    CallContext.FreeNamedDataSlot(ParameterName);
                }
            }
        }

        [Fact]
        public void ConstructorDoesNotModifyTransformationSessionWhenMetadataValueIsNotSpecified()
        {
            using (var transformation = new FakeTransformationWithStringParameter())
            {
                const string ParameterName = "StringParameter";
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) => string.Empty;
                using (new TransformationContext(transformation, transformation.GenerationEnvironment))
                {
                    Assert.False(transformation.Session.ContainsKey(ParameterName));
                }
            }
        }

        [Fact]
        public void ConstructorReportsErrorWhenParameterCannotBeInitializedBecauseSessionIsNull()
        {
            using (var transformation = new FakeTransformationWithStringParameter())
            {
                const string ExpectedValue = "TestValue";
                const string ParameterName = "StringParameter";
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) => metadataName == ParameterName ? ExpectedValue : null;

                CompilerErrorCollection loggedErrors = null;
                transformation.Host.LoggedErrors = errors => loggedErrors = errors;

                transformation.Session = null;
                using (new TransformationContext(transformation, transformation.GenerationEnvironment))
                {
                    Assert.NotNull(loggedErrors);
                    Assert.Contains(ParameterName, loggedErrors.Cast<CompilerError>().Single().ErrorText);
                }
            }
        }

        /// <summary>
        /// Mimics code generated by T4 based on &lt;#@ parameter type="System.Int32" name="IntParameter" #&gt; directive.
        /// </summary>
        private class FakeTransformationWithIntParameter : FakeTransformation
        {
            private readonly int intParameter = 0;

            private int IntParameter
            {
                get { return this.intParameter; }
            }
        }

        [Fact]
        public void ConstructorConvertsMetadataValuesToParameterTypes()
        {
            using (var transformation = new FakeTransformationWithIntParameter())
            {
                const int ExpectedValue = 42;
                const string ParameterName = "IntParameter";
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) => metadataName == ParameterName ? ExpectedValue.ToString(CultureInfo.InvariantCulture) : null;
                using (new TransformationContext(transformation, transformation.GenerationEnvironment))
                {
                    Assert.Equal(ExpectedValue, transformation.Session[ParameterName]);
                }
            }
        }

        [Fact]
        public void ConstructorReportsErrorWhenMetadataValueCannotBeConvertedToParameterType()
        {
            using (var transformation = new FakeTransformation())
            {
                CompilerErrorCollection actualErrors = null;
                const string ParameterName = "Host";
                const string MetadataValue = "InvalidValue";
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) => metadataName == ParameterName ? MetadataValue : null;
                transformation.Host.LoggedErrors = errors => actualErrors = errors;
                using (new TransformationContext(transformation, transformation.GenerationEnvironment))
                {
                    Assert.NotNull(actualErrors);
                    Assert.Equal(1, actualErrors.Count);
                    CompilerError error = actualErrors[0];
                    Assert.False(error.IsWarning);
                    Assert.Contains(ParameterName, error.ErrorText);
                    Assert.Contains(MetadataValue, error.ErrorText);
                    Assert.Contains(transformation.Host.GetType().Name, error.ErrorText);
                }
            }
        }

        #endregion

        #region Current

        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "value", Justification = "C# can't invoke property getter without a variable.")]
        [Fact]
        public void CurrentThrowsTransformationExceptionWhenContextWasNotInitialized()
        {
            Assert.Throws<TransformationException>(() => _ = TransformationContext.Current);
        }

        #endregion

        #region Dispose

        [Fact]
        public void DisposeRaisesDisposedEvent()
        {
            bool disposed = false;
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                context.Disposed += delegate { disposed = true; };
            }

            Assert.True(disposed);
        }

        [Fact]
        public void DisposeInvokesOutputFileManagerWhenThereAreAdditionalOutputs()
        {
            OutputFile[] outputFiles = null;
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile }, TestText);
            }

            Assert.NotNull(outputFiles);
        }

        [Fact]
        public void DisposeInvokesOutputFileManagerWhenThereAreNoAdditionalOutputsSoThatPreviouslyGeneratedFilesCanBeDeleted()
        {
            bool outputFileManagerInvoked = false;
            using (var transformation = new FakeTransformation())
            using (new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFileManagerInvoked = true;
            }

            Assert.True(outputFileManagerInvoked);
        }

        [Fact]
        public void DisposeUpdatesTemplateFileWhenSessionDoesNotHaveInputFile()
        {
            const string TemplateFile = "TestTemplate.tt";
            string actualInput = null;
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.TemplateFile = TemplateFile;
                transformation.Host.UpdatedOutputFiles = (input, outputs) => actualInput = input;
                context.Write(new OutputItem { File = TestFile }, TestText);
            }

            Assert.Equal(TemplateFile, actualInput);
        }

        [Fact]
        public void DisposeUpdatesInputFileWhenSessionHasInputFile()
        {
            const string ExpectedInput = "TestInput.cs";
            string actualInput = null;
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Session[TransformationContext.InputFileNameKey] = ExpectedInput;
                transformation.Host.TemplateFile = "TestTemplate.tt";
                transformation.Host.UpdatedOutputFiles = (input, outputs) => actualInput = input;
                context.Write(new OutputItem { File = TestFile }, TestText);
            }

            Assert.Equal(ExpectedInput, actualInput);
        }

        [Fact]
        public void DisposeLogsTransformationExceptionsThrownByOutputFileManager()
        {
            CompilerErrorCollection actualErrors = null;
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => { throw new TransformationException(TestText); };
                transformation.Host.LoggedErrors = errors => actualErrors = errors;
                context.Write(new OutputItem { File = TestFile }, TestText);
            }

            var error = actualErrors.Cast<CompilerError>().Single();
            Assert.Equal(TestText, error.ErrorText);
        }

        [Fact]
        public void DisposeLogsTransformationExceptionsThrownByTransformationEndedEventHandlers()
        {
            CompilerErrorCollection actualErrors = null;
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.LoggedErrors = errors => actualErrors = errors;
                context.Disposed += delegate { throw new TransformationException(); };
            }

            Assert.Equal(1, actualErrors.Count);
        }

        [Fact]
        public void DisposeReportsTemplateFileInErrorsWhenSessionDoesNotHaveInputFile()
        {
            const string TemplateFile = "TestTemplate.tt";
            CompilerErrorCollection actualErrors = null;
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.TemplateFile = TemplateFile;
                transformation.Host.LoggedErrors = errors => actualErrors = errors;
                context.Disposed += delegate { throw new TransformationException(); };
            }

            Assert.Equal(TemplateFile, actualErrors.Cast<CompilerError>().Single().FileName);
        }

        [Fact]
        public void DisposeReportsInputFileInErrorsWhenSessionHasInputFile()
        {
            const string InputFile = "TestInput.cs";
            CompilerErrorCollection actualErrors = null;
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Session[TransformationContext.InputFileNameKey] = InputFile;
                transformation.Host.LoggedErrors = errors => actualErrors = errors;
                context.Disposed += delegate { throw new TransformationException(); };
            }

            Assert.Equal(InputFile, actualErrors.Cast<CompilerError>().Single().FileName);
        }

        #endregion

        #region GetMetadataValue

        [Fact]
        public void GetMetadataValueThrowsArgumentNullExceptionWhenNameIsNull()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Throws<ArgumentNullException>(() => context.GetMetadataValue(null));
            }
        }

        [Fact]
        public void GetMetadataValueThrowsArgumentExceptionWhenNameIsEmpty()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Throws<ArgumentException>(() => context.GetMetadataValue(" \t\r\n"));
            }
        }

        [Fact]
        public void GetMetadataValueReturnsValueSuppliedByProvider()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                const string ExpectedValue = "TestValue";
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) => ExpectedValue;
                Assert.Equal(ExpectedValue, context.GetMetadataValue("TestProperty"));
            }
        }

        [Fact]
        public void GetMetadataValuePassesHostHierarchyToProvider()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.Hierarchy = new object();

                object actualHierarchy = null;
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) =>
                {
                    actualHierarchy = hierarchy;
                    return string.Empty;
                };

                context.GetMetadataValue("Irrelevant");
                Assert.Same(transformation.Host.Hierarchy, actualHierarchy);
            }
        }

        [Fact]
        public void GetMetadataValuePassesInputFileToProvider()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.TemplateFile = Path.GetRandomFileName();

                string actualFileName = null;
                transformation.Host.GetMetadataValue = (hierarchy, fileName, metadataName) =>
                {
                    actualFileName = fileName;
                    return string.Empty;
                };

                context.GetMetadataValue("Irrelevant");
                Assert.Same(transformation.Host.TemplateFile, actualFileName);
            }
        }

        #endregion

        #region GetPropertyValue

        [Fact]
        public void GetPropertyValueThrowsArgumentNullExceptionWhenNameIsNull()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Throws<ArgumentNullException>(() => context.GetPropertyValue(null));
            }
        }

        [Fact]
        public void GetPropertyValueThrowsArgumentExceptionWhenNameIsEmpty()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Throws<ArgumentException>(() => context.GetPropertyValue(" \t\r\n"));
            }
        }

        [Fact]
        public void GetPropertyValueReturnsValueSuppliedByProvider()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                const string ExpectedValue = "TestValue";
                transformation.Host.GetPropertyValue = (hierarchy, propertyName) => ExpectedValue;
                Assert.Equal(ExpectedValue, context.GetPropertyValue("TestProperty"));
            }
        }

        [Fact]
        public void GetPropertyValuePassesHostHierarchyToProvider()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.Hierarchy = new object();

                object actualHierarchy = null;
                transformation.Host.GetPropertyValue = (hierarchy, propertyName) =>
                {
                    actualHierarchy = hierarchy;
                    return string.Empty;
                };

                context.GetPropertyValue("Irrelevant");
                Assert.Same(transformation.Host.Hierarchy, actualHierarchy);
            }
        }

        #endregion

        #region GetService

        [Fact]
        public void GetServiceDelegatesToHost()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                var expected = ((IServiceProvider)transformation.Host).GetService(typeof(ITransformationContextProvider));
                var actual = context.GetService(typeof(ITransformationContextProvider));
                Assert.Same(expected, actual);
            }
        }

        [Fact]
        public void GetServiceReturnsNullWhenServiceIsNotAvailable()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Null(context.GetService(typeof(ICloneable))); // Bogus service
            }
        }

        #endregion

        #region Host

        [Fact]
        public void HostReturnsHostOfTransformation()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.NotNull(context.Host);
                Assert.Same(transformation.Host, context.Host);
            }
        }

        #endregion

        #region Initialize

        [Fact]
        public void InitializeSetsCurrent()
        {
            using (var transformation = new FakeTransformation())
            {
                TransformationContext.Initialize(transformation, transformation.GenerationEnvironment);
                try
                {
                    Assert.NotNull(TransformationContext.Current);
                }
                finally
                {
                    TransformationContext.Cleanup();
                }
            }
        }

        [Fact]
        public void InitializeThrowsArgumentNullExceptionWhenTransformationIsNull()
        {
            Assert.Throws<ArgumentNullException>(() => TransformationContext.Initialize(null, new StringBuilder()));
        }

        [Fact]
        public void InitializeThrowsArgumentNullExceptionWhenGenerationEnvironmentIsNull()
        {
            using (var transformation = new FakeTransformation())
            {
                Assert.Throws<ArgumentNullException>(() => TransformationContext.Initialize(transformation, null));
            }
        }

        [Fact]
        public void InitializeThrowsArgumentExceptionWhenTransformationIsNotHostSpecific()
        {
            using var transformation = new HostNeutralTransformation();
            Assert.Throws<ArgumentException>(() => TransformationContext.Initialize(transformation, transformation.GenerationEnvironment));
        }

        [Fact]
        public void InitializeThrowsArgumentExceptionWhenTransformationHostIsNull()
        {
            using var transformation = new FakeTransformation();
            transformation.Host = null;
            Assert.Throws<ArgumentException>(() => TransformationContext.Initialize(transformation, transformation.GenerationEnvironment));
        }

        #endregion

        #region Transformation

        [Fact]
        public void TransformationReturnsTransformationPassedToConstructor()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Same(transformation, context.Transformation);
            }
        }

        #endregion

        #region Write

        [Fact]
        public void WriteAppendsToPreviousTemplateOutput()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                context.Write(new OutputItem(), "TemplateOutput");
                transformation.Write("TransformationOutput");
                Assert.Equal("TemplateOutput" + "TransformationOutput", transformation.TransformText());
            }
        }

        [Fact]
        public void WriteThrowsArgumentNullExceptionWhenOutputIsNull()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Throws<ArgumentNullException>(() => context.Write(null, string.Empty));
            }
        }

        [Fact]
        public void WriteAppendsToTransformationWhenOutputFileIsNotSpecified()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Write("TransformationOutput");
                context.Write(new OutputItem(), "TemplateOutput");
                Assert.Equal("TransformationOutput" + "TemplateOutput", transformation.TransformText());
            }
        }

        [Fact]
        public void WriteRespectsTransformationIndentationForSingleLineText()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.PushIndent("\t");
                context.Write(new OutputItem(), TestText);
                Assert.Equal("\t" + TestText, transformation.TransformText());
            }
        }

        [Fact]
        public void WriteRespectsTransformationIndentationForMultilineText()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.PushIndent("\t");
                string text = TestText + Environment.NewLine + TestText;
                context.Write(new OutputItem(), text);
                string expectedOutput = "\t" + TestText + Environment.NewLine + "\t" + TestText;
                Assert.Equal(expectedOutput, transformation.TransformText());
            }
        }

        [Fact]
        public void WriteCombinesTextWrittenToTheSameOutputMultipleTimes()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                var outputInfo = new OutputItem { File = TestFile };
                context.Write(outputInfo, TestText);
                context.Write(outputInfo, TestText);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal(TestText + TestText, outputFile.Content.ToString());
        }

        [Fact]
        public void WriteCombinesTextOfDifferentOutputsWithTheSameFileName()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile }, TestText);
                context.Write(new OutputItem { File = TestFile }, TestText);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal(TestText + TestText, outputFile.Content.ToString());
        }

        [Fact]
        public void WriteCombinesFileMetadata()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;

                var outputInfo = new OutputItem { File = TestFile };
                outputInfo.Metadata["Generator"] = "TextTemplatingFileGenerator";
                context.Write(outputInfo, string.Empty);

                outputInfo.Metadata.Clear();
                outputInfo.Metadata["LastGenOutput"] = "Test.txt";
                context.Write(outputInfo, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal("TextTemplatingFileGenerator", outputFile.Metadata["Generator"]);
            Assert.Equal("Test.txt", outputFile.Metadata["LastGenOutput"]);
        }

        [Fact]
        public void WriteCombinesFileReferences()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;

                var outputInfo = new OutputItem { File = TestFile };
                outputInfo.References.Add("System");
                context.Write(outputInfo, string.Empty);

                outputInfo.Metadata.Clear();
                outputInfo.References.Add("System.Xml");
                context.Write(outputInfo, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.True(outputFile.References.Contains("System"));
            Assert.True(outputFile.References.Contains("System.Xml"));
        }

        [Fact]
        public void WriteSetsFileItemType()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile, ItemType = ItemType.Compile }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal(ItemType.Compile, outputFile.ItemType);
        }

        [Fact]
        public void WriteSetsFileItemTypeForDefaultOutput()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { ItemType = ItemType.Compile }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => string.IsNullOrEmpty(output.File));
            Assert.Equal(ItemType.Compile, outputFile.ItemType);
        }

        [Fact]
        public void WriteSetsFileCopyToOutputDirectory()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile, CopyToOutputDirectory = CopyToOutputDirectory.CopyAlways }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal(CopyToOutputDirectory.CopyAlways, outputFile.CopyToOutputDirectory);
        }

        [Fact]
        public void WriteSetsFileCustomTool()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile, CustomTool = "TextTemplatingFileGenerator" }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal("TextTemplatingFileGenerator", outputFile.CustomTool);
        }

        [Fact]
        public void WriteSetsFileCustomToolNamespace()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile, CustomToolNamespace = "Microsoft" }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal("Microsoft", outputFile.CustomToolNamespace);
        }

        [Fact]
        public void WriteSetsFileDirectory()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile, Directory = "SubFolder" }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal("SubFolder", outputFile.Directory);
        }

        [Fact]
        public void WriteSetsFileEncoding()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile, Encoding = Encoding.UTF7 }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal(Encoding.UTF7, outputFile.Encoding);
        }

        [Fact]
        public void WriteSetsFileEncodingForDefaultOutput()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { Encoding = Encoding.UTF7 }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => string.IsNullOrEmpty(output.File));
            Assert.Equal(Encoding.UTF7, outputFile.Encoding);
        }

        [Fact]
        public void WriteSetsFilePreserveExistingFile()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile, PreserveExistingFile = true }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal(true, outputFile.PreserveExistingFile);
        }

        [Fact]
        public void WriteSetsFileProject()
        {
            OutputFile[] outputFiles = null;

            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                transformation.Host.UpdatedOutputFiles = (input, outputs) => outputFiles = outputs;
                context.Write(new OutputItem { File = TestFile, Project = "Test.proj" }, string.Empty);
            }

            OutputFile outputFile = outputFiles.Single(output => output.File == TestFile);
            Assert.Equal("Test.proj", outputFile.Project);
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenDirectoryIsSpecifiedWithoutFile()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Throws<InvalidOperationException>(() => context.Write(new OutputItem { Directory = "SubFolder" }, string.Empty));
            }
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenProjectIsSpecifiedWithoutFile()
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                Assert.Throws<InvalidOperationException>(() => context.Write(new OutputItem { Project = "Test.proj" }, string.Empty));
            }
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenPreserveExistingFileIsSpecifiedWithoutFile()
        {
            using var transformation = new FakeTransformation();
            using var context = new TransformationContext(transformation, transformation.GenerationEnvironment);
            Assert.Throws<InvalidOperationException>(() => context.Write(new OutputItem { PreserveExistingFile = true }, string.Empty));
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenEncodingIsInconsistent()
        {
            WriteThrowsInvalidOperationException(
                new OutputItem { Encoding = Encoding.ASCII },
                new OutputItem { Encoding = Encoding.UTF8 },
                new[] { "Encoding", Encoding.ASCII.EncodingName, Encoding.UTF8.EncodingName });
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenBuildActionIsInconsistent()
        {
            WriteThrowsInvalidOperationException(
                new OutputItem { ItemType = ItemType.Compile },
                new OutputItem { ItemType = ItemType.Content },
                new[] { "ItemType", ItemType.Compile, ItemType.Content });
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenCopyToOutputDirectoryIsInconsistent()
        {
            WriteThrowsInvalidOperationException(
                new OutputItem { CopyToOutputDirectory = CopyToOutputDirectory.CopyIfNewer },
                new OutputItem { CopyToOutputDirectory = CopyToOutputDirectory.CopyAlways },
                new[] { "CopyToOutputDirectory", "PreserveNewest", "Always" });
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenCustomToolIsInconsistent()
        {
            WriteThrowsInvalidOperationException(
                new OutputItem { CustomTool = "TextTemplatingFileGenerator" },
                new OutputItem { CustomTool = "TextTemplatingFilePreprocessor" },
                new[] { "TextTemplatingFileGenerator", "TextTemplatingFilePreprocessor" });
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenCustomToolNamespaceIsInconsistent()
        {
            WriteThrowsInvalidOperationException(
                new OutputItem { CustomToolNamespace = "T4Toolbox" },
                new OutputItem { CustomToolNamespace = "Microsoft" },
                new[] { "CustomToolNamespace", "T4Toolbox", "Microsoft" });
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenMetadataIsInconsistent()
        {
            var first = new OutputItem();
            first.Metadata["Generator"] = "TextTemplatingFileGenerator";

            var second = new OutputItem();
            second.Metadata["Generator"] = "TextTemplatingFilePreprocessor";

            WriteThrowsInvalidOperationException(first, second, new[] { "Metadata", "Generator", "TextTemplatingFileGenerator", "TextTemplatingFilePreprocessor" });
        }

        [Fact]
        public void WriteThrowsInvalidOperationExceptionWhenPreserveExistingFileIsInconsistent()
        {
            WriteThrowsInvalidOperationException(
                new OutputItem { PreserveExistingFile = false },
                new OutputItem { PreserveExistingFile = true },
                new[] { "PreserveExistingFile", false.ToString(), true.ToString() });
        }

        #endregion

        private static void WriteThrowsInvalidOperationException(OutputItem first, OutputItem second, params string[] keywords)
        {
            using (var transformation = new FakeTransformation())
            using (var context = new TransformationContext(transformation, transformation.GenerationEnvironment))
            {
                first.File = TestFile;
                context.Write(first, string.Empty);

                try
                {
                    second.File = TestFile;
                    context.Write(second, string.Empty);
                }
                catch (InvalidOperationException e)
                {
                    Assert.NotEqual(typeof(TransformationException), e.GetType());
                    foreach (string keyword in keywords)
                    {
                        Assert.Contains(keyword, e.Message);
                    }
                }
            }
        }

        private class HostNeutralTransformation : TextTransformation
        {
            public new StringBuilder GenerationEnvironment
            {
                get { return base.GenerationEnvironment; }
            }

            public override string TransformText()
            {
                throw new NotImplementedException();
            }
        }
    }
}
